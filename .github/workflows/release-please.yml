name: Release Please

on:
  push:
    branches:
    - main

permissions:
  contents: write
  pull-requests: write
  actions: write  # Needed to trigger CI workflow
  statuses: write  # Needed to set commit status for branch protection

jobs:
  release-please:
    runs-on: ubuntu-latest
    outputs:
      pr: ${{ steps.release.outputs.pr }}
      release_created: ${{ steps.release.outputs.release_created }}
    steps:
    - uses: googleapis/release-please-action@v4
      id: release
      with:
        # Use config files for versioning strategy
        # This keeps us in 0.x mode until we're ready for 1.0.0
        # (breaking changes bump minor: 0.x.0, not major: x.0.0)
        config-file: release-please-config.json
        manifest-file: .release-please-manifest.json

  # Trigger CI on release-please branch after PR is created/updated
  # This is needed because GITHUB_TOKEN pushes don't trigger workflows
  trigger-ci:
    needs: release-please
    if: needs.release-please.outputs.pr != ''
    runs-on: ubuntu-latest
    outputs:
      run_id: ${{ steps.trigger.outputs.run_id }}
      head_sha: ${{ steps.trigger.outputs.head_sha }}
    steps:
    - name: Trigger CI workflow and get run ID
      id: trigger
      uses: actions/github-script@v7
      with:
        script: |
          // Parse the PR object from release-please output
          const prData = ${{ needs.release-please.outputs.pr }};
          const branchName = prData.headBranchName;

          console.log(`PR #${prData.number}: ${prData.title}`);
          console.log(`Triggering CI on branch: ${branchName}`);

          // Get the branch's head SHA before triggering
          const { data: ref } = await github.rest.git.getRef({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: `heads/${branchName}`
          });
          const headSha = ref.object.sha;
          console.log(`Head SHA: ${headSha}`);

          // Set pending status on the commit
          await github.rest.repos.createCommitStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            sha: headSha,
            state: 'pending',
            context: 'All Checks Passed',
            description: 'CI workflow triggered, waiting for completion...'
          });

          // Trigger the CI workflow
          await github.rest.actions.createWorkflowDispatch({
            owner: context.repo.owner,
            repo: context.repo.repo,
            workflow_id: 'ci.yml',
            ref: branchName
          });

          // Wait a moment for the workflow to start
          await new Promise(resolve => setTimeout(resolve, 5000));

          // Find the triggered workflow run
          const { data: runs } = await github.rest.actions.listWorkflowRuns({
            owner: context.repo.owner,
            repo: context.repo.repo,
            workflow_id: 'ci.yml',
            branch: branchName,
            per_page: 5
          });

          const run = runs.workflow_runs.find(r => r.event === 'workflow_dispatch');
          if (run) {
            console.log(`Found CI run: ${run.id}`);
            core.setOutput('run_id', run.id);
          } else {
            console.log('Could not find workflow run, but CI was triggered');
            core.setOutput('run_id', '');
          }
          core.setOutput('head_sha', headSha);

  # Wait for CI to complete and report status back to the PR
  report-status:
    needs: [release-please, trigger-ci]
    if: needs.trigger-ci.outputs.run_id != ''
    runs-on: ubuntu-latest
    steps:
    - name: Wait for CI and report status
      uses: actions/github-script@v7
      with:
        script: |
          const runId = ${{ needs.trigger-ci.outputs.run_id }};
          const headSha = '${{ needs.trigger-ci.outputs.head_sha }}';

          console.log(`Waiting for CI run ${runId} to complete...`);

          // Poll for completion (max 30 minutes)
          const maxWait = 30 * 60 * 1000;
          const pollInterval = 30 * 1000;
          const startTime = Date.now();

          while (Date.now() - startTime < maxWait) {
            const { data: run } = await github.rest.actions.getWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId
            });

            console.log(`Run status: ${run.status}, conclusion: ${run.conclusion}`);

            if (run.status === 'completed') {
              const state = run.conclusion === 'success' ? 'success' : 'failure';
              const description = run.conclusion === 'success'
                ? 'All CI checks passed'
                : `CI failed: ${run.conclusion}`;

              await github.rest.repos.createCommitStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                sha: headSha,
                state: state,
                context: 'All Checks Passed',
                description: description,
                target_url: run.html_url
              });

              console.log(`Set commit status: ${state}`);
              return;
            }

            await new Promise(resolve => setTimeout(resolve, pollInterval));
          }

          // Timeout - set error status
          await github.rest.repos.createCommitStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            sha: headSha,
            state: 'error',
            context: 'All Checks Passed',
            description: 'CI workflow timed out'
          });

          core.setFailed('CI workflow timed out after 30 minutes');
